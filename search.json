[{"title":"堆相关数据结构学习（二）——bin","date":"2021-11-23T01:30:49.000Z","url":"/2021/11/23/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94bin/","tags":[["Heap","/tags/Heap/"]],"categories":[[" ",""]],"content":"What is bin用户释放掉的chunk不会马上归还系统，而是会先丢进各种bin里面，当用户再次请求分配内存时，ptmalloc分配器会试图从bin中挑选空闲的合适的一块chunk给用户。这样可以避免频繁的系统调用，降低内存分配的开销。 bin初步分为4类：fast bins，small bins，large bins，unsorted bin，其内部又有更细化的划分。 对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下 bins 主要用于索引不同 bin 的 fd 和 bk。以 32 位系统为例，bins 前 4 项的含义如下 含义 bin1 的 fd/bin2 的 prev_size bin1 的 bk/bin2 的 size bin2 的 fd/bin3 的 prev_size bin2 的 bk/bin3 的 size bin 下标 0 1 2 3 bin2 的 prev_size、size 和 bin1 的 fd、bk 是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd、bk。 也就是说，虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。 数组中的 bin 依次如下 第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。 索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。 small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。 此外，上述这些 bin 的排布都会遵循一个原则：任意两个物理相邻的空闲 chunk 不能在一起。 需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk 先放到 fast bins 的容器内。而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。 bin 通用的宏如下 Fast Bin 大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。因为我们把大部分时间花在了合并、分割以及中间检查的过程中。 因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY "},{"title":"绿城杯总结","date":"2021-09-30T04:51:28.000Z","url":"/2021/09/30/%E7%BB%BF%E5%9F%8E%E6%9D%AF%E6%80%BB%E7%BB%93/","tags":[["wp","/tags/wp/"],["z3","/tags/z3/"]],"categories":[[" ",""]],"content":"前言上午上课，中午开始看的题目 说实话，这次的比赛有把我捞到，哎 总结经验，吸取教训吧 easy_re常规题，不多bb。 main函数有个花指令，去一下 反编译看main函数 观察算法特征，是RC4，但是有个细节变异 多了个异或0x37 key也有，密文动调得到 编写exp 抛石机这题是真的吃了浮点转换和运算的亏了，他的判断逻辑还是比较好把握的 这里是判断输入的格式，必须得是flag&#123;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&#125;，字符x的内容可变 cont是x的内容，8个字节为一组，然后存入4个全局变量中 然后是check函数，内容如下： 其实就是两个2元一次方程，一共得4个解。 不是等式方程（有个范围值，但很小），有师傅索性直接等于0，然后求解方程。 其实用范围约束来爆破得到的结果其实也一样，这个就不管了，不是我总结这题的重点 check函数开头有两个判断，可以用来判断一个2元1次方程的两个解应该分别是哪个变量 求解方程脚本——z3 由输出结果加上前面的分析可以判断： x == 1.08063237896641294938 y == 4.32516472248286241293 z == -0.48267319186340060660 l == 1.97762268681289555610 转16进制形式exp——struct坑点都在注释里写上了 无坑写法——C其实C语言本身带的格式控制符写这种浮点数的题比python更自然一点，直接copy其他师傅的脚本了： babyvxworks这题说实话是自己放弃了，vxworks好像是固件逆向，没做过，以为自己不会，没太认真看 后面看了下wp发现也就那样。。认真看应该是能做出来的 有很多花指令，有点去不干净**(tcl**，等一个大佬的去花wp，逻辑比较简单，就不分析了 exp直接copy的ChaMd5的exp "},{"title":"关于dll注入","date":"2021-08-09T12:08:00.000Z","url":"/2021/08/09/%E5%85%B3%E4%BA%8Edll%E6%B3%A8%E5%85%A5/","tags":[["实战逆向","/tags/%E5%AE%9E%E6%88%98%E9%80%86%E5%90%91/"]],"categories":[[" ",""]],"content":"前言最近在学游戏实战逆向的一些东西，记些微不足道的笔记。之前也有做过关于dll注入的逆向题，当时官方wp是结合函数名泄露写dll注入解的，我复现的时候是照着别人的wp结合ce分析挖掘dump代码做的，因为不太理解dll注入，坑留到现在，所以先补一补dll注入的一些知识和API的学习。 什么是dll注入dll（Dynamic Link Library）意为动态链接库，一般dll文件里面通常包含各种功能实现的函数等。 dll注入就是将自己编写的dll注入到进程中去，常用的注入方式是远程线程注入，这里主要记录一下这种注入方式 DLL里编写实现我们功能的代码，在加载入进程中后让其立马执行 远程线程注入dll常规步骤如下： 查找窗口，获取窗口的句柄 根据窗口句柄,查找进程PID 根据进程PID，获得进程句柄 给远程进程申请空间,并且返回空间的首地址 将要注入的DLL的路径写入进程内存中 远程进程开辟线程,调用LoadLibrary,加载dll 调用退出代码,释放远程线程的dll与注入类似，就是远线程调用FreeLibrary卸载DLL 参考资料iBinary："},{"title":"堆相关数据结构学习（一）——chunk","date":"2021-08-07T04:41:13.000Z","url":"/2021/08/07/%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94chunk/","tags":[["Heap","/tags/Heap/"]],"categories":[[" ",""]],"content":"What is chunk由malloc申请的内存称之为chunk。在ptmalloc内部用malloc_chunk结构体来表示。 无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。 malloc_chunk的结构如下： 处于已分配状态的chunk内存如下：（图中少标了一个标志位）前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处即图中的mem。 处于释放状态的chunk：此时 fd，bk 有效 可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小 本身的 size 字段会记录， 它后面的 chunk 会记录。 chunk相关宏chunk与mem指针头部的转换 最小的chunk大小等同于 MINSIZE 其中，offset()函数算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含到 bk 指针。 检查分配给用户的内存是否对齐 请求字节数判断就是判断请求的内存大小是否可以满足 request2size ——将用户请求内存大小转为实际分配的内存大小 大致流程如下： 判断用户请求的字节大小是否可以满足，REQUEST_OUT_OF_RANGE 由于chunk间存在复用，所以当前chunk若是用来分配，则下一个chunk的 prev_chunk 也属于当前chunk的user_data部分 若 请求大小 + SIZE_SZ 对齐后的大小小于MINSIZE则直接分配MINSIZE 若大于，则再进行 2*SIZE_SZ 对齐 标记相关chunk标志位进行或运算，用于掩码 通过chunk指针p 对某标志位进行提取、检查、置位和清除 要注意，当前chunk的使用状态是由下一个chunk的size成员的低比特位决定的。 获取chunk size 获取下一个物理相邻的chunk当前chunk指针加上当前chunk的大小以获得 获取（修改）前一个chunk的信息仅当前一个chunk处于释放状态有效 当前chunk使用状态相关操作即对下一个chunk的size对象的标志位操作 设置 chunk 的 size 字段set_head_size 不会改变当前 chunk 的标志位（这里书是这么写，但单实现好像不然，这里先不管）而 set_head 会 获取指定偏移的 chunk直接把指定偏移处看作chunk 指定偏移处 chunk 使用状态相关操作 chunk 合并和拆分过程涉及到bin，先把bin学了再回来更。"},{"title":"ROP","date":"2021-08-05T01:03:39.000Z","url":"/2021/08/05/ROP/","tags":[["ROP","/tags/ROP/"]],"categories":[[" ",""]],"content":"What is ROPROP（返回导向编程），主要用来针对NX保护机制，当堆栈不可执行，就将栈溢出后返回地址导向程序已有指令，当这些指令都已ret指令结尾时（被称作gadget），则可通过组合串联执行达到某些目的。 ROPgadgetROPgadget工具可以自动扫描二进制文件中可供利用的gadget，甚至能自动构造利用链（懒狗福音，只是实际做题能遇见的不多就是了。。） ROP的内存布局示例payload中各条gadget地址与其参数（通常用于pop指令）布局大致如下 日常使用 ret2libc简单的ret2text和ret2shellcode就不说了，主要讲一讲ret2libc的东西 libc简介要讲ret2libc就得先理解libc与可执行文件的关系，下面讲的也只是我目前的理解（如有误请指正） 一个动态链接的可执行文件和libc的关系大概就是，可执行文件运行时所需的共享对象会被链接到文件中，但其实整个libc都被加载在了虚拟内存中（这时还没有为其分配真正的物理内存，等切时要执行时才分配），这才有了ret2libc的可能。而有些可执行文件里面能被IDA加载后静态看得见的那些libc函数，都是文件中实际包含的，而没有的libc函数如system在确定libc在内存中的实际地址和函数偏移后一样可以利用。 一般的利用套路当二进制文件中没有明显的后门函数，而又开启了NX保护不能直接注入shellcode执行。可以利用ROP链泄露已执行过的一些函数的实际地址，再用LibrarySearcher匹配找到对应libc，算出该函数在虚拟内存中的实际地址与在libc中的地址的偏移即可算出我们想要利用的libc函数在内存中的实际地址。 system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。 即使程序有 ASLR 保护，也只是针对于地址中间位进行随机，最低的 12 位并不会发生改变。 —— ctfwiki 一道例题ctfwiki-ret2libc3"},{"title":"格式化字符串","date":"2021-07-31T01:00:43.000Z","url":"/2021/07/31/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":[["格式化字符串","/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"categories":[[" ",""]],"content":"前置知识在x86的结构下，格式化字符串的参数是通过栈传递的。换言之，printf()函数打印出来的数据都直接来源于栈。 %n转换指示符将当前已成功写入流或者缓冲区的字符个数存储到由参数指定的地址中去，意味着printf也有写入内存能力。 %n$则可以指定第n个参数 指示符 类型 输出 %d 4-byte Integer %u 4-byte Unsigned Integer %x 4-byte Hex %s 4-byte ptr String %c 1-byte Character %p 4-byte Hex addr 长度 类型 输出 hh 1-byte char h 2-byte short int l 4-byte long int ll 8-byte long long int 漏洞原理当格式字符串可以被外部更改时，则可构造特定格式字符串达到泄露、修改任意地址内存数据。 例如： printf(&quot;%4$s&quot;)会输出栈上对应偏移为4处地址 所指的内存数据 printf(&quot;\\x78\\x56\\x34\\x12&quot;)会将值0x12345678写入栈对应偏移处 上面两点结合起来就可泄露任意地址内存，如(假设偏移为4)：printf(&quot;\\x78\\x56\\x34\\x12:%4$s&quot;)则会输出地址0x12345678处的内容 pwnlib.fmtstrpwntools里提供了利用格式化字符串漏洞的一些工具 class pwnlib.fmtstr.FmtStr(execute_fmt, offset=None, padlen=0, numbwritten=0) execute_fmt ( function ) – 调用与易受攻击的进程进行通信的函数 offset ( int ) – 您控制的第一个格式化程序的偏移量 padlen ( int ) – 要在有效负载之前添加的 pad 的大小 numbwritten ( int ) – 已经写入的字节数 当不给出参数offset时，则尝试通过泄漏堆栈数据来找到正确的偏移量，事实上可以总是这么做 主要参数是execute_fmt，一般要视程序来编写，基本模板如下： class pwnlib.fmtstr.fmtstr_playload(offset=None, writes, numbwritten=0, write_size=&#39;byte&#39;) offset ( int ) – 您控制的第一个格式化程序的偏移量（可由上面构造方法自动获取） writes ( dict ) – 带有 addr, value 的 dict&#123;addr: value, addr2: value2&#125; numbwritten ( int ) – printf 函数已经写入的字节数 write_size ( str ) – 必须是byte,short或int。告诉你是要一个字节一个字节写，一个短写还是一个 int 写（hhn、hn 或 n） 实例HITCON CMT 2017: pwn200 漏洞利用思路 开了Canary，没法直接栈溢出劫持返回地址，所以可以先调试找到Canary存放的地址，再利用格式化字符串泄露Canary的值，在栈溢出时覆盖上去即可 完整exp如下： "},{"title":"pwntools学习","date":"2021-07-25T03:13:22.000Z","url":"/2021/07/25/pwntools%E5%AD%A6%E4%B9%A0/","tags":[["pwntools","/tags/pwntools/"]],"categories":[[" ",""]],"content":"简述Pwntools 分为两个模块，一个是pwn，简单地from pwn import *即可将所有子模块和常用系统库导入； 另一个是pwnlib，可以根据需要导入子模块，而不是像上面这个这样all in…（正常人谁不all in还一个个挑呢hhh） 常用的子模块pwnlib.tubes 通常用于与目标文件或者目标服务器进行交互 主要函数在pwnlib.tubes.tube中实现，子模块只负责某个管道特殊的地方。四种管道及其子模块如下： pwnlib.tubes.process: 进程 p = process(‘/bin/sh’) pwnlib.tubes.serialtube: 串口 pwnlib.tubes.sock: 套接字 r = remote(‘127.0.0.1’, 1080) l = listen(1080) pwnlib.tubes.ssh: SSH s = ssh(host = ‘example.com’, user = ‘name’, password = ‘passwd’) pwnlib.context用于设置运行时变量，如目标系统、目标体系结构、端序、日志等 pwnlib.elf用于操作ELF文件，包括符号查找、虚拟内存、文件偏移、以及修改和保存二进制文件等功能。 pwnlib.asm用于汇编和反汇编代码（确保已安装对应体系结构的binutils），体系结构、端序、字长等信息可以作为asm()的参数，但最好通过pwnlib.context来设置。 pwnlib.shellcraft使用这个模块可以生成各种体系结构（aarch64、amd64、arm、i386、mips、thumb等）的shellcode代码 pwnlib.utilutil其实是模块的集合，包含了一些小工具。这里介绍俩packing和cyclic。 未完待续..参考资料 《CTF竞赛权威指南（PWN篇）》 "},{"title":"Canary_attack","date":"2021-07-22T01:31:38.000Z","url":"/2021/07/22/Canary-attack/","tags":[["Canary","/tags/Canary/"],["Stack","/tags/Stack/"]],"categories":[[" ",""]],"content":"Stack Canaries 前置知识原理 Stack canaries(取名自地下煤矿地金丝雀，因为它能提前发现煤气泄漏，有预警的作用)。用于对抗栈溢出攻击，即SSP安全机制，也叫Stack Cookie。Canary是栈上的一个随机数（大小与程序位数一样），当栈溢出攻击从低地址向高地址覆盖意图控制函数的返回指针时，就一定会先覆盖到Canary，这样程序只需在函数返回前检查Canary是否被篡改即可达到保护目的。 Canary通常分三类： Terminator canaries：低位设置为&quot;\\x00&quot;，一定程度上防止字符串操作溢出泄露canary Random canaries：程序初始化时随机生成一个值作为canary Random XOR canarie：上面的random多个XOR操作，无论时canary还是XOR的数据被篡改都会报错 Linux下的TLS及canaryfs寄存器一般用于指向TLS，TLS的结构体tcbhead_t（64位）中偏移0x28正指向stack_guard，一般检测栈溢出的过程就是，程序加载时glibc先初始化TLS，包括为其分配内存及设置fs寄存器指向TLS（这一部分由系统调用arch_prcl完成），然后调用security_init()函数生成Canary的值stack_chk_guard，并放入fs:0x28，检测的时候对比这个值是否发生变化。 攻击Canarie核心思路就是避免程序崩溃抛错，有两种方式： 将canaries的值泄露出来，栈溢出的时候覆盖上去使其保持不变（PS：Canaries的值一般在存放返回函数地址之前的8/4个字节上） 同时篡改TLS和栈上的Canaries 实例一：2017 NJCTF messager查看基本信息 程序有个地方打开了flag文件,存放到一个变量中，查看交叉引用又找到了回送flag的函数（溢出返回的地址get） 自己写一个flag文件，修改一下messager的权限，打本地。 再看看主函数的一个循环 知识补充 当一个进程调用fork()复刻子进程时，系统会给子进程分配资源，并将父进程的所有值复制到子进程中，相当于克隆父进程。父进程中调用fork()返回子进程的pid，而子进程中调用fork()时返回值是0，失败则返回负值。 一般来说canarie的值是没法直接爆破的，一是因为canarie的值范围大，二是因为爆破导致程序崩溃重启后的Canarie值可能又会重新随机生成。但是同一个进程包括复刻的子进程里的Canaries是不变的，而子进程的崩溃也不会影响父进程，这就有了可乘之机。 溢出点在函数sub_400Be9()中，向0x64大小的变量存放至多0x400大小的数据 综合分析下来exp就出来了 参考资料 《CTF竞赛权威指南（PWN篇）》 "},{"title":"wasm逆向","date":"2021-07-14T16:25:45.000Z","url":"/2021/07/15/wasm%E9%80%86%E5%90%91/","tags":[["wp","/tags/wp/"],["wasm逆向","/tags/wasm%E9%80%86%E5%90%91/"],["蓝帽杯","/tags/%E8%93%9D%E5%B8%BD%E6%9D%AF/"]],"categories":[[" ",""]],"content":"BHC-Calc暑假复现之路漫漫。。 关于wasm这里的工具可以把wasm转成c代码 关于wasm逆向的一篇很好的帖子 调试wasm chrome输入地址  即可运行wasm程序 f12控制台可以下断点调试 本题解法首先通过上面的方法得到c代码和优化后的.o文件（上面帖子里有方法） 把html调起来，会发现，click checking！先是调用了一个check_input()函数，接着里面调用Module.ccall() 接着步入，调用了一个h函数（.c里和IDA反编译.o里的w2c_h函数） IDA里的内容如下： 解释一下，成功和失败的字符串都在data_segment_data_0里面，calc.c里有这么一句LOAD_DATA(w2c_e, 1024u, data_segment_data_0, 641);意思是把data_segment_data_0里的内容载入w2c_e+1024处 这里计算1024+61刚好就是1085,也就是”Oops….something wrong”的偏移 再就是这里有一串奇怪的16进制编码：0x77678b0f3e6cf6e263e6fe3a4c39f3多半和flag脱不了干系 这里往后我就有点没分析出来了，T神用改输入观察结果的方法找规律发现是0x80进制的算法变换 套用这个结论写exp "},{"title":"buu-re-97","date":"2021-04-24T08:05:21.000Z","url":"/2021/04/24/buu-re-97/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"],["MFC","/tags/MFC/"]],"categories":[[" ",""]],"content":"[HDCTF2019]MFC前言最近刷的题难度都不是很高，主要都是学习新知识。这题主要是考察C++ 的MFC的（主要是加了个vmp1的壳，vmp的壳好像都都挺难脱的）。 参考资料：   简单了解一下MFCMFC（微软基础类库），主要是作用在Windows平台的GUI开发（不过好像已经有点过时了） Windowns消息机制 API 应用程序编程接口（Application Programming Interface） WindowsAPI函数是通过C实现的，主要在windows.h头文件中进行了声明 窗口和句柄 一个Windows应用程序至少要有一个窗口，称为主窗口。窗口时屏幕上的一块矩形区域，是Windows应用程序与用户进行交互的接口，利用窗口可接受用户输入及显示输出。 而每个窗口都有一个唯一标识的句柄（HWND） 消息和消息队列 Windows程序设计是一种基于“消息”的事件驱动模式。简单来说就是：对于一个窗口，操作系统会感知各种事件（如点击鼠标，键盘敲击等），这些事件被包装成消息，应用程序通过一个虚幻来不断从消息队列中取出消息，并进行响应。 简单了解一下xspy的使用界面很简单，长这样 用法就是把那个“放大镜”拖到要检测扫描的窗口上就行了 作用：可以扫出这个窗口的一些基本信息，包括监听的消息和处理该消息的函数地址（我是这么理解的） 本题解法硬岔vmp先不管，打开文件弹了个窗 xspy扫一下 得到的信息： 窗口句柄（HWND=001FADE） 句柄后括号里面那串信息（创建窗口时的类名）：944c8d100f82f0c18b682f63e4dbaa207a2f1e72581c2f1b 一个奇怪的消息监听：OnMsg:0464,func= 0x00402170(mfc.exe+ 0x002170 ) PS：这里解释一下OnMsg，0x0464可以理解为消息内容（其他WM开头那些是属于系统消息），后面的func可以理解为，接受到这个消息后所跳转的响应函数 直接写个脚本发送这条消息给这个窗口触发一下试试（不会写，抄其他师傅的exp学习一下） 触发后窗口变了 这已经提示得很明显了，上DES解密，密文就是长串类名 "},{"title":"MRCTF-EzGame","date":"2021-04-20T03:05:58.000Z","url":"/2021/04/20/MRCTF-EzGame/","tags":[["wp","/tags/wp/"],["MRCTF","/tags/MRCTF/"],["CE使用","/tags/CE%E4%BD%BF%E7%94%A8/"]],"categories":[[" ",""]],"content":"MRCTF-EzGame前言这是道U3D的游戏逆向，用借着这道题把Cheat Engine“游戏作弊”以及配合dump内存分析的方法思路给大致过了一遍，还挺有意思的 关于分析Unity 3dU3D的主要逻辑一般在Assembly-CSharp.dll文件里，可以拖入dnspy里找关键的逻辑代码 PS：C#的string默认字符编码是Unicode，这点要注意，昨天也是一道u3d的题目，里面加密算法的key是key=&#39;1234&#39;，但实际上自己写exp的时候key要写成key=b&#39;1\\x002\\x003\\x004\\x00&#39; C# 的所有源代码文件，默认编码为 UTF-8，注意，是源代码文件，而不是 C# 中的 string。 C# 中的所有 string，默认编码均为 Unicode (UTF-16)。 C# 产生的 ASP.NET 源代码，如 ASPX/CS，在浏览器响应回去客户端之后，编码默认为 UTF-8。可以通过 ContentType 请求头信息更改默认编码。比如：ContentType: application/json, charset=utf-8。————————————————原文链接： 简单介绍一下il2Cpp及il2CppDumper就是一个将C#语言写的脚本处理转成了C++，我的理解主要是为了有更好的可移植性和运行效率 这里有较为详尽的介绍： 但是这样处理之后Assembly-CSharp.dll就无了，替换成了GameAssembly.dll和*Assembly.dll 这个拖进dnspy是没用的，没什么信息，有个il2CppDumper可以实现反编译回原来的Assembly-CSharp.dll（有一些基本信息，但是没代码） 这题就是这样的..根据提示选择dll和global-metadata.dat，反编译的结果在DummyDll文件夹里 本题解法官方WP的做法是通过反编译得到得信息结合il2Cpp的API写dll注入脚本来解的，dll注入日后再弄。这里先学一下别的师傅结合ce的做法 四个任务分别是： 应该是到终点的意思 找到某个npc 吃到饼干 吃到105个钻石 ps：一开始尝试手动通关，有个地方怎么也跳不过去，可能是故意设（wo）置（tai）的（cai）吧hh 用CE找到关键数据内存启动游戏，打开ce添加游戏进程 扫描搜索数据，这里好像吃钻石的数量比较好搜，边吃边搜，直到搜索结果锁定在关键的几个位置，基本就没错了（可以尝试修改后在游戏查验来确认） 然后看一下反编译后的dll里的信息： 有各个关键数据的偏移地址：像这样 然后可以用ce里的Structure dissect（在Memory View中的tool里面）来整理这些相关数据，不过要注意设置数据的字节长度，像这里的key实际上是8字节的，要给他右键改一下 全部给他按照要求修改后 getflag显示 应该是和flag相关的key不对，其实反编译出来有个函数叫EatTokenUpdateKey,应该是每吃一个钻石key都会更新，所以单纯地修改钻石数量是不行的。 结合dump内存分析ce里有个功能特方便，可以找到修改（或访问）指定内存的位置，右键就能看到。 那先把设置里的debugger改成VEH（好像可以绕过一些反调试？），然后右键key的内存，“找到哪修改了着这个地址的内存” 然后去吃颗星星触发 可以跟进进去直接在ce里看到修改位置的汇编码，能看伪代码吗？可以！ 网上有很多的dump进程内存的工具，我用的火绒剑，把内存dump出来后直接拖进ida可以反编译（这方法好像可以脱一些壳？） 要在ida里找到函数对应的位置可以搜索函数头的字节，search里有一栏sequence of bytes，勾选一下那个Find all occurrences 注意要dump正确的文件（dll），但是不知道为啥我这里没法正确反编译，就tmlp…放一下别人的图吧 最后把这个函数撸一遍把正确的key跑出来再去ce里面修改就行了，这个就不说了。"},{"title":"IDA动态调试mips架构文件","date":"2021-04-08T12:48:04.000Z","url":"/2021/04/08/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95mips%E6%9E%B6%E6%9E%84%E6%96%87%E4%BB%B6/","tags":[["动态调试","/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"],["mips","/tags/mips/"]],"categories":[[" ",""]],"content":"IDA动态调试mips架构文件最近mips的题目前前后后遇见了3，4次了，难度都不大（结合动调分析的话hh） 配动调mips架构文件的环境配了好久，虽然还没有完全搞定，但好歹是能跑部分的mips题目了 安装qemu 命令安装 编译安装（推荐） 官网下载： 这里有个教程 ./configure，缺什么依赖就装 起调试 虚拟机里执行： ​ 其中1234是端口 可能会遇到的问题： 报错显示没有 XX.so 之类的，先看看系统里面有没有这个文件sudo find / -name XX.so ；然后用cp 将找到的文件copy到/usr/lib 打开主机的IDA 下好断点 debugger 选择 remote gdb debugger process option ：hostname 填虚拟机ip，端口填刚才那个 attach to process -&gt;ok "},{"title":"IDApython","date":"2021-03-30T10:16:44.000Z","url":"/2021/03/30/IDApython/","tags":[["IDApython","/tags/IDApython/"]],"categories":[[" ",""]],"content":"前言之前用的是 IDA7.0 ，每次要写idapython的时候就看这个网站备忘倒也还算方便，但是自从换了7.5，好多idapython的写法都变了，每次不记得就得查官方的API变动很是麻烦，还是记一下IDA7.5下的一些常用的函数 常用的函数接口PS: idc 前缀的函数可省略不写 idc 地址获取 数值获取 操作码获取 数据判断 搜索操作搜索失败时返回-1 修改操作"},{"title":"buu-re-79","date":"2021-03-30T00:48:27.000Z","url":"/2021/03/30/buu-re-79/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"],["SMC","/tags/SMC/"],["AES","/tags/AES/"],["分组加密","/tags/%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86/"]],"categories":[[" ",""]],"content":"[SCTF2019]creakme前言小结一下这题考察的几个知识点： SMC及其恢复patch AES加解密 分组密码模式判断 基础base64编码 分析一开始就发现了内存中有一段奇怪的code，结合调用处信息，基本可以判断是一个SMC但是我一直没找到修改这段code的地方..后来参考了一下WP，说是SMC的代码在sub_402450那么问题又来了，如何在哪里调用了这个函数？又是怎么传参的？WP里面说是附加在调试器下调用的，我又去看了看汇编代码，理了下逻辑： edx(a1)传入要修改的总字节长度（但是怎么给edx赋的值还没弄懂..） ecx(a2)传入要修改的起始地址 修改的过程伪代码很容易看明白，贴一下恢复的exp 然后对应对应地址 c 一下 p 一下 f5一下，被隐藏起来的代码就出来了 text原来是&gt;pvfqYc,4tTc2UxRmlJ,sB&#123;Fh4Ck2:CFOb4ErhtIcoLo 就是text[i]偏移后，再逆序变为 nKnbHsgqD3aNEB91jB3gEzAr+IklQwT1bSs3+bXpeuo= 然后用Findcrypt插件扫一下，发现有base64和AES加密 再看主函数，主要的加密逻辑在sub_4020D0里 AES_CBC（CBC模式从AES加密函数中有个像是偏移量的变量sctfsctfsctfsctf;分组加密的各个模式的区别在这） 然后再一个base64编码 逆向的话反过来就行 exp 这个网站也可以解"},{"title":"DASCTF三月赛","date":"2021-03-29T06:55:00.000Z","url":"/2021/03/29/DASCTF%E4%B8%89%E6%9C%88%E8%B5%9B/","tags":[["wp","/tags/wp/"],["DASCTF","/tags/DASCTF/"]],"categories":[[" ",""]],"content":"drinkSomeTea题目本身不难，就是一个tea加密，但是用python写这个脚本属实是坑多，给折磨了好久 主要的坑 python 的右移运算符 &gt;&gt; 是逻辑右移（左补0），c语言里的 &gt;&gt; 是算术右移（左补符号位） 文件读写的大端序小端序的问题，也借此简单学习了一下python的struct库 以后遇见这种文件读写的题目还是用c写吧，害 分析通过下面这里fake_flag在内存中的排放可知，这个程序是小端序的，所以写脚本的时候也要注意小端序输出字节流 然后看一下加密的核心源码（润色后的） exp直接放解密脚本吧（python），里面的算术右移函数是抄的Mas0n师傅的脚本 一个小技巧一般常见格式的文件，像这次这种png，他都有一些固定的文件头，可以观察正确格式下对应文件的文件头来辅助逆向分析 Enjoyit-1这题其实蛮简单，边吃饭边看，吃完饭就出解了 分析是c#写的，拖进dnSpy，贴一下主要逻辑代码 先是一个魔改了编码表的base64加密后密文的判断 然后中间具体的先不看，密文判断完后，有一个很长的sleep（图中只sleep了1秒，原来好像是10w秒来着，直接给他改了），然后好像是输出正确flag 修改一下源码，保存，再运行，flag直接出，关键的解密逻辑甚至看都不用看 replace虽然说这题难度标的是困难，但给我的感觉倒不是最难的，那道扫雷到现在我都还一点头绪没有2333（稍微玩了一下，应该是少了一行，没法全扫光） 说回这道题目，一开始没去管太多，看到一个异或加密，直接写个脚本跑一下，好家伙果然是fake flag hhh 然后再仔细分析了下，发现一些反调试和花指令，去花之后真正的逻辑就容易看出来了 这题没什么太多新东西，就直接贴脚本了 flag{Sh1t_you_dec0d3_it}"},{"title":"filpgame","date":"2021-03-15T07:26:09.000Z","url":"/2021/03/15/filpgame/","tags":[["wp","/tags/wp/"],["z3","/tags/z3/"],["V&N2021","/tags/V-N2021/"]],"categories":[[" ",""]],"content":"虽然比赛结束后才做出来，但还是蛮有成就感的嘿嘿 为了做出这道题，又多学了一些新知识~~ 程序分析首先，无壳32位。 然后又去百度了一下filpgame，出来了一些flipgame（翻转游戏）的内容，具体就是：一个黑白子棋盘，翻转一个棋子之后，上下左右四个棋子状态也翻转（黑变白，白变黑），最终使得棋盘所有棋子颜色统一。 带着这样一个基本概念打开IDA分析，贴一下我的分析注释： 基本逻辑就是： 读入的数据都是十六进制数形式的字符（0F），其中AF是大写字母 text有基础值，二进制16*16的形式就是个棋盘： 1011111011110101100010111011110010100000111010010111001100010000110110010001000010100011101011011100110010110110010011011101111000110100010011000011101111010110011001110001000110000110100011110001110001111010100001000010010101101011000011010001101101001100 读入的数据，（从0开始）奇数位表示行，偶数位表示列，每两个数一组组成要改变状态的棋子的位置 最后判断棋盘是否全为1，全为1即正确 分析的一些小坑 key 和 key2的值一开始不太好看出来是啥玩意，干脆动调调出来，然后再结合flipgame的概念，发现是个辅助进行各个方向棋子翻转的东西 动调的时候发现i的值是0，4，8，12，16（按理不是0~4么），有点迷惑，看汇编发现是每次i+4，&gt;0x14时退出循环，反编译这么智能么hhh exp网上现成的flipgame脚本大多都是递归爆破的，16*16的棋盘规模时间复杂度差不多O(2^256)?跑到明年去。。 又看到一篇讲filp解法原理的知乎 就想到用z3列方程来解，但是一开始用z3只能出1个解，还不符合要求,又去学了下z3求多组解的方法： 就是while s.check()==sat结合s.add(Or(s.model[] != 找到的解))来实现 下面是完整的脚本： vnctf{md5(跑出来的结果)}"},{"title":"buu-re-73","date":"2021-03-03T06:43:51.000Z","url":"/2021/03/03/buu-re-73/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"],["ollvm混淆","/tags/ollvm%E6%B7%B7%E6%B7%86/"]],"categories":[[" ",""]],"content":"[安洵杯 2019]game这题主要是数独结合了ollvm混淆，题目本身的算法并不难，但是加了ollvm混淆就让分析工作量增大了不少 关于ollvm这个ollvm混淆主要就是将程序的基本快之间的控制关系打乱，而交由统一的分发器进行管理（这个待会结合题目会讲到），实现控制流平坦化。 解决控制流平坦化混淆有两个开源脚本工具：deflat.py(这个好像是针对x86架构下的混淆)和HexRaysDeob 《0到1》——NU1L：“这些通用的反混淆工具能解决的只是一部分标准的控制流平坦化混淆，但原版的ollvm工具在2017就停止维护了，现有的修改版ollvm大多是由个人维护的，一般会增加一些新功能，或者新的实现方式，干扰脚本分析。” 所以，做这题这两个工具我都没用上（扛着混淆硬干的555） 由于上诉原因，一般实际逆向过程中，难以指望上这些反混淆工具。较好的方法是对一些关键数据（如输入的flag）内存读取/或写入设置断点，静态和动态结合起来，找到关键的逻辑，复现出这些基本块之间真正的逻辑。 PS：分析过程中关注那个主分发器，一般是个大量出现在判断语句的变量 本题解法首先看看main函数(大致分析变化过后的) 从后往前，先来看看check3 看看check2,太长了就不全部贴出来了。。看看这个流程图吧hh 大概的逻辑就是，D0g3也就是那个初始未解数独，将输入的flag（check1变化后）先-48再依次填入D0g3中的非0元 再贴一下check1的关键逻辑 input[119] 和 input[2039]交换 2个一组 互相交换 类似异或的操作（逆向的时候重复操作就行） 分析完，贴完整脚本（解数独用网站上的就行了） flag{KDEEIFGKIJ@AFGEJAEF@FDKADFGIJFA@FDE@JG@J}"},{"title":"符号执行angr","date":"2021-02-17T09:13:23.000Z","url":"/2021/02/17/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8Cangr/","tags":[["angr","/tags/angr/"]],"categories":[[" ",""]],"content":"前言记：又一个逆向神器——angr，详情参考官方文档，这里面的example是ctf的一些题例 然后这里是一些angr解题的题库，我还没做过,以后慢慢练习 一个简单的demo，应该能大致了解angr 一些example我自己也写了一个简单的demo，程序是这样的： 利用angr来跑，目的就是要让其执行到success处 又一个example——DEFCON 2016 quals baby-re angr的一些知识点记得可能不全，可用性也不强，日后熟悉了再慢慢更新 hookhook_symbol：angr提供hook一些库函数得接口，从而实现其功能，在angr/procedures中可以看到这些库 例： hook(addr=xx,hook=hook_demo,length=xx) ：程序自定义的函数没法直接hook，但是可以hook调用这个函数的地址，然后以自己的逻辑写一个hook_demo，length是hook_demo后要跳过的指令的长度 例： ps：hook的是一个state，自己实现hook_demo中的一切操作都是基于传递过来的state find 和 avoid关于expolor里的find和avoid，都是可以是list类型，也就是可以批量avoid（一般不会批量find吧..） 而批量avoid的地址则可以通过idapython的提取出来，这个关于idapython，就迟些学了再记 还有一个比较好用的find的方法：直接以标准输出中的关键字符串为目标去find 就像这样s.explore(find=lambda st: b&quot;Congrats&quot; in st.posix.dumps(1)) pie保护pie保护的程序，每次运行时的地址都会有变化，就像这样 但在angr中，程序的基址是固定在0x400000处的 所以在相关地址提取的时候加上0x400000即可 PS:但是ida加载的时候，每次动调之后地址都会变，所以只能参考第一次刚加载进ida时的地址"},{"title":"buu-re-54","date":"2021-02-14T01:51:21.000Z","url":"/2021/02/14/buu-re-54/","tags":[["动态调试","/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"],["buu","/tags/buu/"],["wp","/tags/wp/"],["二叉树遍历","/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"]],"categories":[[" ",""]],"content":"number_game这道题是一道二叉树遍历的逆向，数据结构刚学完2个月，看的时候完全没想起来树的相关知识，搁那跟踪递归，头都快跟晕了。还有一些动调的问题，一并在这里记一下。 首先，文件无壳，64位elf,ida打开 先看看先序遍历sub_400758 画个图吧，以输入序列：0123456789来看 先序遍历赋值完后v3就是上面这棵树 然后sub_400807就是将中序遍历v3的结果赋给v7，具体代码如下： 中序遍历的结果就是7,3,8,1,9,4,0,5,2,6 解题脚本： flag{1134240024} 动调一开始开动调一步一步跟着递归，实在是有点费脑子，后来就想着干脆直接绕过输入合理性检测，输入个0123456789看最终的v7序列得了，便做了以下尝试patch完后发现动调始终达不到目的，依旧会进入checkenable，输入不合理的时候依然会给 eax 赋0，不知道咋回事，害 后来看别的师傅的wp的时候发现ida还可以在调试状态下动态修改标志寄存器。。（不好意思，wtcl） 这样的话，就在会检测到不合理的地方下断点每次跳转前修改一下ZF让他不跳转，然后往下执行，就可以得到想要的v7了！"},{"title":"二进制代码保护和混淆","date":"2021-02-12T09:15:57.000Z","url":"/2021/02/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4%E5%92%8C%E6%B7%B7%E6%B7%86/","tags":[["二进制代码保护和混淆","/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81%E4%BF%9D%E6%8A%A4%E5%92%8C%E6%B7%B7%E6%B7%86/"]],"categories":[[" ",""]],"content":"多摘自NU1L的《0到1》 抵御静态分析花指令：指在程序中完全冗余，不会影响程序功能，但会干扰逆向的指令。没有固定形式。 脏字节：会导致反汇编或反编译解析错误的多余字节（或指令） 反正就是很奇怪的指令多半就有问题 遇到花指令或者脏字节需要仔细分析上下文，找到有毛病的指令或字节进行patch 指令替换（变形）还有一些题目为达成混淆效果，会故意将一些指令用其他指令来实现相同或类似的功能。如 代码自修改（SMC）原理就是在算法脚本中认为地写一段代码将可执行代码修改，让 真正执行的代码不在静态分析中出现。 一般，SMC的代码在ida工具中会被识别为数据，但会将该数据的地址当作函数指针并进行调用。 解决方案： 静态分析SMC代码的自修改过程并复现出真正执行的代码 动态分析至SMC代码解密完毕出并设置断点，然后往下接着分析 加密主要是指对数据，代码，指令等进行加密保护，VMProtect是一种很强的加密壳。（这个就先记到这个程度） 反调试概念：指在程序代码中运用若干种反调试技术，干扰对某个进程进行动态调试、逆向分析的手段。 简单来说就是：检测到你正在动态调试程序，然后执行干扰代码。 如： Windows下正在被调试的进程的PEB中的BeingDebugged字段会被置为true，由此诞生了IsDebuggerPresent()API，用来检测当前进程是否正在被调试。 Linux下调用的ptrace也是类似的道理 Windows API: IsDebuggerPresent() CheckRemoteDebuggerPresent() NtQueryInformationProcess() 绕过方法： 手动：找到反调试语句所在，进行相应修改绕过 ScyllaHide 时间间隔检测单步跟踪的时候指令运行所耗费的时间长得多，基于此来检测 如：x86cpu中存在一个TSC（时间戳计数器）的64位寄存器RDTSC指令会将TSC的值读入EDX:EAX寄存器中。一般实现这种反调试只需探测TSC的低32位变化量（即EAX的变化量）。绕过方法：在没有变化量下界的情况下，将所有相关RDTSC（0F 32）指令替换成xor eax（33 C0） 基于异常的反调试这个还没见过，所以先不细学，记个大概 绕过方法一般是对所使用的调试器进行配置，使之忽略程序产生的特定异常。 对于x64dbg而言：顶部菜单-&gt;选项-&gt;选项-&gt;异常-&gt;添加上次忽略上一个产生的异常类型。其他调试器同理。 TLS反调试**Thread local Storage(TLS)**，即线程本地存储，是为解决一个进程中多个线程同时访问全局变量而提供的机制。Windows提供了TLS回调函数机制，借此实现反调试。 解决方案：IDA静态分析下可以很好地识别TLS回调函数。动态调试以x64dbg为例，顶部菜单-&gt;选项-&gt;选项-&gt;事件中勾选“TLS回调函数”项，再调试程序，会停在TLS回调函数被调用前，然后再跟踪分析 特定调试器检测就是检测所用调试器 断点检测这个大概看了一遍，没太搞懂，先放着（也还没见过）"},{"title":"逆向常见算法识别","date":"2021-02-12T04:23:43.000Z","url":"/2021/02/12/%E9%80%86%E5%90%91%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB/","tags":[["算法识别","/tags/%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB/"]],"categories":[[" ",""]],"content":"这里大多数内容摘自NU1L的《0-1》，目前见到用到的东西不多，现在总结记录在这里，方便日后遇到的时候好查看，也有个思考的方向 特征值识别很多常见的算法如：AES、Base64 会用到一些对应的固定常量，通过识别这些常量从而推断猜测所用到的算法，下面放一个书上的表 特征运算识别还可以通过某些算法的特征运算来推测识别，也放一个表 ps：有些题目会针对这些固定算法做变换（包括在常量和运算上的一些小变换），分析的时候还是要仔细确认好 第三方库识别算法中可能会使用一些现成的库，对这些库进行针对性的识别可以提高逆向分析的效率，下面是ida识别第三方库的一些方法 字符串识别很多第三方库会将版权信息和该库使用的一些字符串（如报错信息）以字符串的形式写入库中。通过寻找这些字符串可以快速判断使用了哪些第三方库 函数签名识别在确定了使用的库之后，可以进一步识别具体函数 当IDA函数列表或者导航栏有大部分青色区域，就属于识别函数，这时可以手动应用：shift+f5打开Signature列表，然后insert可以新增匹配的函数签名库 第三方库函数也有类似上述的方法：ida文件菜单 -&gt; Load File -&gt; FLIRT Signature file,对应添加就行，若ida没有预置所需识别的库函数签名，这里查github.com/push0ebp/sig-database，对应签名放进sig文件夹，然后在IDA中加载 二进制对比识别工具：BinDiff安装使用："},{"title":"buu-re-49","date":"2021-02-11T03:05:21.000Z","url":"/2021/02/11/buu-re-49/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[[" ",""]],"content":"firmware这题其实没什么逆向上的难度，就是几个工具的使用，借这个题记一下 binwalk —提取bin文件首先附件得到的是个bin后缀的文件，ida什么的是打不开的了。用linux的binwalk的一个文件提取 命令是binwalk -e filename.bin，然后文件目录下就会有个xx.bin.extracted文件夹 打开之后查看一番也没有想要的东西，有个120200.squashfs文件，是linux的一种压缩文件 firmware-mod-kit —提取squashfs文件从官方文档记一些功能，也不一定都会用到: CRCALC-一种用于重新计算和修补通用固件标头的校验和字段的新工具。目前支持TRX和uImage标头UNTRX-一种将TRX图像内容提取到其组成部分的新工具UNSQUASHFS-支持提取2.x squashfs图像的自定义混合。直到squashfs 3.0才正式提供此工具，所以直到现在为止，该工具不适用于2.x图像WRT-VX-IMGTOOL-一种用于查看，提取，构建和修复WRT54G（S）v5系列的VxWorks兼容固件映像的新工具SPLITTER3-用于某些类型的Linux固件映像的自定义文件拆分器 这题用unsquashfs_all.sh提取上面得到的120200.squashfs文件 完了之后提取的文件存在了/firmware-mod-kit/src/squashfs-root 里,找到关键文件backdoor 接下来ida打开backdoor分析，找到网址和端口就行了 flag{md5(echo.byethost51.com:36667)}"},{"title":"汇编笔记9","date":"2021-02-09T09:32:04.000Z","url":"/2021/02/09/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B09/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"整合：第十二章和十三章 关于内中断内中断的一些概念当cpu内部发生一些情况时，会产生一些需要处理的中断信息，会对应有相应的处理 对于8086cpu，有下四种中断情况： 除法错误，如div指令产生的除法溢出：中断类型码（下同）0 单步执行：1 执行into指令：4 执行int指令: int n就是n 中断向量表8086cpu的向量中断表放在0000：0000 ~ 0000：03ff处，一个表项存一个中断的信息 大概长这样： 每个中断对应的地址共占2个字的大小 高地址字存cs 低地址字存ip 中断过程 中断类型码为 n 的中断发生 标志寄存器压栈并置 TF=IF=0 当前cs 和 ip 压栈（先压cs后ip） cs：ip指向中断向量表中n号中断的所指向的地址 执行所指地址的中断程序（也叫中断例程） *一般中断例程中都有iret指令（作用类似于ret）相当于执行 pop ip , pop cs , popf 自己编写中断例程 编写中断例程 利用movsb指令将例程代码送入到合适的内存区（如0000：0200~0000：02ff，中断向量表一般有很多空闲单元，且不会被其他程序占用） 将 n 号中断里的地址改为上述所选内存的地址 例：编写、安装7ch中断，将data段以0为结尾的字符串转化为大写 ps：中断程序中iret指令的妙用：利用压入在栈中中断发生处的cs：ip可以令iret跳转到想跳转的地方去。 例：在屏幕中间显示80个’!’"},{"title":"汇编笔记8","date":"2021-02-03T15:52:42.000Z","url":"/2021/02/03/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B08/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第十一章 标志寄存器标志寄存器（flag寄存器）在8086中结构如图 影响标志寄存器的大都是运算指令（逻辑和算数运算） 而传送指令（如mov push pop等）都不会影响标志寄存器 ps：inc 和dec 也不会影响标志寄存器 ZF（zero）零标志 结果为0时：zf=1 结果为非0时：zf=0 PF（parity）偶数标志 结果的二进制有偶数个1时：pf=1 奇数时：pf=0 SF（sign）负数标志 结果为负时：sf=1 结果为非负时：sf=0 CF（carry）进位（借位）标志无符号运算 结果存在向最高位的更高位进位（借位）：cf=1 没有进位（借位）：cf=0 OF（overflow）溢出标志有符号运算 运算结果超过结果载体表示范围：of=1 ~ 没超过：of=0 DF（direction）方向标志与串传送指令DF标志在串处理指令中，控制每次操作后si、di的增减 df=0：每次操作后si、di递增指令cld 设置df=0 df=1：每次操作后si、di递减指令std 设置df=1 movsb（字节串传送）实现的东西就相当于mov es:[di],ds[si] ;8086并不支持这样的指令inc si ;df=0inc di ;df=0 movsw（字型数据串传送） 类上 以上只是串传送的一个步骤，通常还要配合rep指令 如：rep movsb就相当于 它的循环次数也由cx决定 adc指令操作格式：adc 对象1，对象2 功能： 对象1=对象1+对象2+cf 用来实现大数相加（可以处理进位） sub指令操作格式：sbb 对象1，对象2 功能： 对象1=对象1-对象2-cf 用来实现大数相减（可以处理借位）和adc的作用意义类似 cmp 指令与j类跳转指令指令格式：cmp 对象1，对象2 实质上就是计算对象1-对象2，只不过不保留运算结果，通常用来与j类跳转指令配合使用 j类指令如下： pushf 和 popf pushf：将flag寄存器的值压栈 popf：将栈中的数据弹入到flag寄存器 "},{"title":"汇编笔记7","date":"2021-02-02T04:22:19.000Z","url":"/2021/02/02/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B07/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第十章 call和ret指令call 指令执行的时候，先把call指令后的第一个字节的IP或CS和IP压栈，然后跳转到需要跳转的地方执行命令，类似调用函数 ret（或retf） 指令，用栈的数据修改IP（近转移）或CS和IP（远转移），达到跳转的目的，通常配合call指令完成类似调用函数然后返回的作用 call和ret指令的用法 乘法指令 mul相乘的两个数，要么都是8位，要么都是16位 都是8位 一个相乘的数默认放在al，另一个放在8位的reg或内存字节单元中结果默认放在ax 都是16位 一个相乘的数默认放在ax，另一个放在16位的reg或内存字节单元中结果：结果的高位默认存在dx，低位默认存在ax 对于call和ret配合设计的函数调用为防止寄存器使用上的冲突，一般在call进去的时候将要用的寄存器压栈，使用完后在ret前出栈 当寄存器不够用来传参或返回结果时，可以用内存单元或栈空间来代替"},{"title":"buu-re-21","date":"2021-02-01T18:04:13.000Z","url":"/2021/02/02/buu-re-21/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"],["RSA","/tags/RSA/"]],"categories":[[" ",""]],"content":"RSA的经典算法，还是记一下吧。。。 这是RSA的具体细节 打开是这些文件 无疑是个rsa解密，key里的内容如下 这是个公钥，全部复制到这个网站可以得到N和E N = “模数” E = “指数” 然后由N = p*q 算出p，q；用yafu工具，指令是factor(N) 然后算密钥D（用python gmpy2模块） D = gmpy2.invert(e,(p-1)*(q-1)) 最后算出key key = rsa.PrivateKey(n,e,int(d),p,q)，这里int(d)是必不可少的，不然会报错 完整脚本： "},{"title":"buu-re-15","date":"2021-02-01T10:46:36.000Z","url":"/2021/02/01/buu-re-15/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"]],"categories":[[" ",""]],"content":"本来刷题是不打算再这么频繁地写博客的，可这题实在是太好玩了 我的解法检查无壳，32位 cmd运行试试发现要一个登录密码，一开始猜想密码就是flag，然后拖入ida静态分析 静态分析进入主要函数，看到程序开始运行所显示的一些内容，随便下了个断点开始逐步分析 一直到输入密码的地方，发现有个strcmp函数 发现是与字符串HelloWorld作比较，再打开程序，验证密码，发现密码正确，进入一个新界面 发现有个flag的东西，就尝试控制方向键选中flag打开 得到一个所谓虚假的flag：V2h5IGRvbid0IHlvdSB0cnkgdGhlIG1hZ2ljIGJyaWNrIGdhbWU= 像是base64编码，解码后是一句话“Why don’t you try the magic brick game” 砖块游戏？我便打开“打砖块”游戏,也没咋玩，过一会游戏结束flag显现flag{f5dfd0f5-0343-4642-8f28-9adbb74c4ede} 网上别人的wp看了别人wp才知道，正确flag是一个base58解码 2i9Q8AtFJTfL3ahU2XGuemEqZJ2ensozjg1EjPJwCHy4RY1Nyvn1ZE1bZe 转：flag&#123;f5dfd0f5-0343-4642-8f28-9adbb74c4ede&#125; base58编码算法的特征这里记一下base58的特征，下次好认得 编码表123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ 无‘0’数字+大小写字母 编码步骤ascii码（看成256进制）-&gt;转成10进制 -&gt;转成58进制 -&gt;对应编码表"},{"title":"buu-re-13","date":"2021-01-31T13:30:15.000Z","url":"/2021/01/31/buu-re-13/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"]],"categories":[[" ",""]],"content":"刮开有奖这题还挺有意思，考察的点不少，学到的技巧也不少 本题做法Exeinfope检查，无壳，32位 拖入ida查看，进入关键函数 关于升序排序函数sub_4010f0这里的是关于这个排序函数的伪代码分析，但是我没具体去分析算法意思 因为没耐心。。不过对伪代码分析还是有帮助的 动态调试及绕过前面说我没耐心分析那个排序算法却又能得出结论，就是利用了动态调试 但是再调的过程中发现找不到输入端口，没法改变函数中的一些判断，直接跳转到了别的地方 因此就找到了判断的汇编指令处，通过修改绕过判断，达到调试的目的 完了之后就是这样了，可以正常调试 flag{UJWP1jMp}"},{"title":"汇编笔记6","date":"2021-01-31T07:17:01.000Z","url":"/2021/01/31/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B06/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第九章 转移指令的原理8086CPU 的转移 一些指令 所有的转移，超界(比如短转移超过128个字节)编译都会报错 实验九贴一下实验9的内容吧 "},{"title":"z3在逆向中的应用","date":"2021-01-29T09:23:39.000Z","url":"/2021/01/29/z3%E5%9C%A8%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","tags":[["z3","/tags/z3/"]],"categories":[[" ",""]],"content":"什么是z3z3是一个python api，可用来辅助完成一些带约束条件的未知数求解 一言以蔽之：用来解方程 用法教程这两个应该够用了，放在这备忘： [] [] 我使用的一些例子增广矩阵求解未知数这题是wust蚁景杯里的equation “位运算”处理求解Z3为符号数运算提供了一个特殊的运算符操作版本 其中运算符&lt;，&lt;=，&gt;，&gt; =，/，％和&gt;&gt;对应于有符号运算 相应的无符号运算符是ULT，ULE，UGT，UGE，UDiv，URem和LShR 这是蚁景杯的easypyc z3，逆向神器"},{"title":"wust蚁景杯","date":"2021-01-28T03:36:03.000Z","url":"/2021/01/28/wust%E8%9A%81%E6%99%AF%E6%9D%AF/","tags":[["wp","/tags/wp/"],["蚁景杯","/tags/%E8%9A%81%E6%99%AF%E6%9D%AF/"]],"categories":[[" ",""]],"content":"X0rupx壳 用工具先脱壳 然后拖进ida 就是一个多次异或的变换，逆向就是编写脚本把Str2再重复一遍这些异或操作即可 flag{XOR_1n_Re_1s_E4sy} ez_re64位elf，拖进ida 进入crypto函数发现加密函数如下 解题脚本如下 flag{uNp4ck_1s_b@sic_5kill_Of_r3} tablespyc文件；网上找到反编译工具反编译一下 代码及分析如下 解题脚本如下： flag{ismytablethateasytocrack} babyjvav.class 文件，拖进idea查看 代码及分析如下 因为不知道原flag字符，分析后大胆猜测flag是字母开头，就以26个字母遍历开头字母来推后续字符 一开始是以小写字母来遍历，发现有一个像flag的字符串jVAV\u0011Sn\u0010Te\u0014SY；但是有乱码 又换大写字母遍历，flag就出来了； python脚本如下： flag{Jvav_1s_N0t_E4sy} easypyc先反编译pyc，如下： 很简单的一个变换算法，但一开始我思考逆向的时候，陷入了16进制整体变换的泥坑，思不得解 经某昊爷启发，二进制逐位异或去思考便很容易找到规律 脚本如下 "},{"title":"汇编笔记5","date":"2021-01-25T08:56:57.000Z","url":"/2021/01/25/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B05/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第八章 数据处理的两个基本问题 处理的数据在什么地方 要处理的数据有多长 bp寄存器用法类似于bx，si，di [bp] 表示的物理地址的段地址为段寄存器ss存的值 指令处理的数据长度标识一般的寄存器，如ax，al，bh，是可以起到位数标识作用的 但对内存单元的操作就没有这种默认标识 所以需要指明要操作的内存长度 word ptr byte ptr 例子：mov byte ptr [0],ff div指令格式： 除数：有8位和16位的 8位：被除数就是16位的，默认存在ax；结果存在ax中，al为商，ah为余数 16位：被除数就是32位的，默认存放在dx和ax中（高16位存在dx，低16位存在ax）；结果的商存在ax中，余数存在dx中 例子：计算100001/100 ； 因为要分别为dx和ax赋100001的高16位值和低16位值所以先化为16进制 100001=186A1H dd伪指令dd就是用来定义 dword（double word） dup定义的时候，用来进行数据的重复 使用格式： 例子：db 3 dup (&#39;abc&#39;,&#39;ABC&#39;) 定义了18个字节，它们是’abcABCabcABCabcABC’,相当于db &#39;abcABCabcABCabcABC&#39;"},{"title":"汇编笔记4","date":"2021-01-23T15:22:08.000Z","url":"/2021/01/23/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B04/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第七章 更灵活的定位内存地址的方法and 和 or 指令以及字母大小写转换 原理就是利用and和or的特性： and：将操作对象的相应位设为0，其他位不变 or：将操作对象的相应位设为1，其他位不变 而and al,11011111b中的第5位为0（位数从0开始数），相当于就是al-2^5=al-32; or al,00100000b同理 定位地址首先，寄存器si和di与bx功能类似，是16位寄存器，但不能分为两个8位寄存器来使用（即bx有bh和bl，而si和di就没有） 这3个寄存器共同利用起来就像是高级语言循环中层层循环中的i，j，k那样 寻址方式灵活运用 多重循环的实现总的思路就是，因为只有1个cx循环计数的寄存器，所以外层循环的cx可以先存起来，存的地方： 普通寄存器 某个内存空间 栈（一般用这个） 内循环的cx正常赋值使用，当内循环结束后，再将存好的外层循环的cx值重新赋给cx进行外层循环的递减，判断 给个栗子（改变每个字符串的前4个字母）： 就这么多~"},{"title":"迷宫类题目一些伪代码小经验","date":"2021-01-23T03:36:49.000Z","url":"/2021/01/23/%E8%BF%B7%E5%AE%AB%E7%B1%BB%E9%A2%98%E7%9B%AE%E4%B8%80%E4%BA%9B%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%B0%8F%E7%BB%8F%E9%AA%8C/","tags":[["迷宫","/tags/%E8%BF%B7%E5%AE%AB/"],["二维数组伪代码","/tags/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%AA%E4%BB%A3%E7%A0%81/"]],"categories":[[" ",""]],"content":"说是关于迷宫类题的，其实就是二维数组伪代码的审计问题 先上码 行走方向和标识符在注释处； 挑一个函数来讲left((_DWORD *)&amp;v9 + 1)：参数意思就是修改高32位，left里面的内容是(*传进来的地址)-- 就是把二维数组[][]看成 [低32位]（行）[高32位]（列） 应该还有很多表示这种意思的伪代码，这里只记录一下这一种思想 具体迷宫问题可以参考"},{"title":"IDA动态调试elf","date":"2021-01-19T17:49:49.000Z","url":"/2021/01/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95elf/","tags":[["动态调试","/tags/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"],["IDA","/tags/IDA/"]],"categories":[[" ",""]],"content":"今天第一次用IDA动态调试elf，这题本不太需要，就是想借此把elf的调试方法和步骤过一遍，踩了好多坑… 把ida中的linux_server(多少位的程序就用对应的server)拖入linux 把要调试的elf也一并拖入linux，和server放在同一目录下；然后chmod 777 server文件名改属性；终端运行server若blind: Address already in use，则先netstat -nap查看运行server程序的pid，然后kill -9 pid以结束进程，再重新运行server 配置IDA Debugger 选择remote linux debugger前三个是目录，前两个要包含elf文件的名字，Hostname为虚拟机的ip程序设置好断点，F9 可能遇到的问题 其实上面那个文件路径好像也可以不配置，默认是啥就是啥不用改，他到时候会报个错，点copy new就行了 程序可能因人为设置没法调试，今天这个buu-re-11的题就是这样其中的原因和方法今天先放一放 修改文件指令的时候要记得写入文件保存edit-patch-apply 修改后的文件要拖入linux覆盖，这样才能生效 "},{"title":"buu-re-11","date":"2021-01-19T17:23:12.000Z","url":"/2021/01/20/buu-re-11/","tags":[["buu","/tags/buu/"],["wp","/tags/wp/"]],"categories":[[" ",""]],"content":"查壳&amp;脱壳Exeinfope 一下 IDA64 静态分析 进入关键函数Decry() 逆向偷个懒，配置一下环境动态分析，直接得到text和key text=’killshadow’ key=’adsfkndcls’ 分析后，按理说逆向结果应该是不唯一的，因为大小写的处理是一样的，但是根据提交结果和网上wp发现是全大写（所以我觉得这题出得不太好），那脚本就简单了： flag{KLDQCUDFZO}"},{"title":"汇编笔记3","date":"2021-01-19T02:00:34.000Z","url":"/2021/01/19/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B03/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第五章 [bx]和loop指令[bx][bx] 意味 地址为bx中的内容的偏移地址 loop用cx和loop指令配合实现循环的功能的框架如下: 记个ps：汇编源程序中，数据不能以字母开头，所以字母开头的数据要在前面加0 Debug中跟踪 loop 的命令p 命令 ：在遇到loop指令时，用p指令可以直接将循环运行至结束 g 命令 ：g 要跳转的IP 可以直接使程序运行到要跳转的IP的地方 Debug和masm对指令的不同处理先看区别debug中：mov ax,[1]意味将ds:[1]的内容送进axmasm编译时: 上面这个指令意味将数值1送入ax 即[idata]在debug中是一个内存单元”idata”是内存单元的偏移地址；而masm编译器将[idata]解释为”idata” 解决方法 将偏移地址送进bx，用[bx]来达到上述目的 显示地在[…]前面加上段寄存器，如mov al,ds:[0] 一段安全的空间DOS和其他合法程序一般都不会使用0:200~0:2ff这256个字节空间 所以往这里面写内容一般是安全的 实验程序在debug中加载后，cx寄存器的初始值就是程序段的长度。"},{"title":"汇编笔记2","date":"2021-01-16T02:37:06.000Z","url":"/2021/01/16/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B02/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[[" ",""]],"content":"第三章 寄存器（内存访问）内存中字的存储 内存单元==字节单元 字单元：由两个连续的内存单元组成，16位寄存器存储一个字，高8位地址存高字节，低8位地址存低字节 DS和[address] DS寄存器通常用来存放要访问的数据的段地址直接上例子 8086CPU中，往DS里面写东西只能以mov ds,寄存器的方式，而不能像ax寄存器那样mov ax,1CPU在执行上述类似指令的时候，会将[…]里的内容作偏移地址，取默认存在ds里的作为段地址来访问对应内存 字的传送 一个例子： mov、add、sub指令 mov add&amp;sub 经实验，add和sub不支持寄存器与段寄存器之间的操作 体会数据和程序的区别 例： 程序和数据本身存放形式没有区别，关键是看存的的段地址：ds段的就是数据，cs段的就是程序指令。 CPU提供的栈机制 push ax ：表示将寄存器ax中的数据送入栈（字型数据高位字节先入栈） pop ax 表示从栈顶取出数据送入ax（先出的为低位字节） 入栈和出栈操作都是以字为单位进行的 8086CPU中的SS(段寄存器)：SP(寄存器)在任意时刻都指向栈顶元素。push和pop指令执行时，CPU从SS和SP中得到栈顶地址 入栈时，栈顶从高地址向低地址方向延伸 栈空时，SS：SP指向栈空间最高地址单元的下一个单元，如： push 和 pop都有可能导致栈顶越界 8086CPU不会保证我们对栈的操作不会超界，要自己操心~ push 和 pop 指令 push(pop) 寄存器/段寄存器/内存单元"},{"title":"hexo博客搭建","date":"2021-01-15T11:19:15.000Z","url":"/2021/01/15/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","tags":[["hexo","/tags/hexo/"]],"categories":[[" ",""]],"content":"怕踩坑的建议先把这篇文章全看完后，再着手开始 hexo + github 部署个人博客看这个应该差不多了，这里面的工具先装，后面都要用的 具体怎么写博客建议下个文本编辑器，有很多种，我用的是VSCODE 在博客目录下右键打开git bash，然后hexo n 文章名 ，这样就在站点根目录下的source下的_post里面建了一个 文章名.md ，博客内容在里面写就好了，对了，写博客还得学一下markdown语法，下面给个例子(我这篇文章的 .md文件) 如上，文章的一些分类，标签功能什么的都在开头的---包裹里面写 选好自己喜欢的主题后仔细阅读该主题的README和config文件里的内容，修改一下基本个人信息和设置啥的 遇到的问题大多数可以百度得到 选主题，和美化博客其实挺让人上头的，我是上了这个当了，前前后后搞了不下4，5天，其实没太大必要，博客能用就行，最主要的还是写东西进去。 话是这么说，我还是把后来踩的坑总结一下吧 评论系统其实我感觉 这里建议选主题的时候看一下是否有自带评论系统，最好是自带，不然自己想要后来添加想用的评论系统会比较麻烦，我反正是在这里是失败了，不得不换了个主题重新搞。 就是选主题的时候看一下里面的config文件，看一下有没有你想要的评论系统支持。 我个人推荐valine，评论用户不用注册，简洁，加载速度也比较快。 这里给一下valine官网 友链功能想要友链功能又不想自己写的(想白嫖)，选主题的时候也注意一下有没有友链功能，然后看主题里的文件看怎么用，实在搞不懂就直接去作者github下开issue问(没错就是我了) 没什么用的看板娘这里给两种方式 一个网址，照着这里来就可以，优点是简单快捷，缺点是可用模型比较少这里有模型预览 一个视频，这个步骤就稍微复杂了点，但有模型就能换(上面那个方法好像也能换现有模型，但是我没成功，就不管了，愿意试坑的可以去搞一搞)视频相关资源我也一并放这了(没有live2d viewer，用模拟器开live2d萌宠没有萌宠商店，没用——试过了)我这没有的估计你也不好找代码模型资源(提取码:txnp)，我稍微收集了一部分，想预览的话只能看看里面的那个模型部件图~~ps:里面的lpk其实是一个压缩包，加个后缀名.rar，然后解压就行了 最后最后推荐几个主题吧： next(用的人超级多，网上关于这个主题的配置啊，问题解决方案啥的超级多) fan(我自己看到的比较好看的还不错的) polarbear(究极简) card(不推荐 - ) "},{"title":"汇编笔记1","date":"2021-01-12T03:43:30.000Z","url":"/2021/01/12/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B01/","tags":[["汇编笔记","/tags/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"]],"categories":[["学习笔记-汇编语言（王爽）","/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89/"]],"content":"大概一年前学了一点，后来就搁置了，这个寒假捡回来给他冲完 第二章 寄存器一个寄存器分为高位和低位，如AX寄存器分为AH和AL 当寄存器中存放的数据超出位数限制大小时，寄存器只会保留没有超出的那部分，如 mov ax 8226H add ax 8226H 这其中ax计算的值理应为1044CH，但是限于AX寄存器是16位大小，寄存器中最终的值为044CH，进位1并不是真的丢弃（书中暂未提，后续再记） 在进行数据传送和运算时，要注意指令的两个操作对象位数应当是一致的 如 mov ax bh 就是错误的指令 物理地址（对于8086CPU）*物理地址=段地址16+偏移地址** 起始地址=段地址*16（必然是16的倍数） 16位地址的寻址能力为64KB，因此一个段的长度最大为64KB 可以用不同的段地址和偏移地址形成同一个物理地址 例子： 相当于通过地址加法器将两个16位地址合成为一个20位的物理地址 段寄存器：CS，DS，SS，ES CS和IPCS为代码段寄存器，IP为指令指针寄存器8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行一个最简单的修改CS：IP的指令jmp jmp 段地址：偏移地址 jmp 某一合法寄存器 jmp ax指令执行前: ax=1000H，CS=2000H，IP=0003H指令执行后: ax=1000H，CS=2000H，IP=1000H 记一些debug实验的内容吧。 R命令：查看、修改CPU寄存器的内容例： 分别执行了查看各寄存器、修改CS寄存器、修改IP寄存器 D ：查看内存中的内容 E ：修改内存中的内容（前提是该内存可修改）关于此有一个实验题是要求在fff00~fffff中找到pc主板机上ROM中写有的一个生产日期并试图修改它。 以下是我的实验过程👇 我成功找到并试图修改其内容，但修改后再查看发现其并没有改变，再回头看提示，才想明白该内存段是属于rom的地址空间，而rom为只读内存，无法修改。 U ：将内存中的内容解释为机器指令和对应的汇编指令例 T ：执行CS：IP指向的内存单元处的指令（t一次执行一次，ip自动跳转下一个指令）例 A ：以汇编指令的形式向内存中写入指令例"},{"title":"迷宫","date":"2021-01-11T14:50:21.000Z","url":"/2021/01/11/wust_maze/","tags":[["wp","/tags/wp/"],["迷宫","/tags/%E8%BF%B7%E5%AE%AB/"]],"categories":[["RE-WP","/categories/RE-WP/"]],"content":"这是好久之前做的学校的一个re了，简单回顾一下 64位exe，丢进ida，字符串搜索找到main，f5后是这样的 简单分析一下，发现flag与a这个数组有关，a里面的内容是这样的，一串由P Z W组成的字符串 意思就是最后让a[a1]这个值==W即a1最终要等于’W’所在的下标；而a1在move()中变化，再看看move()这个函数 到此大致可以猜出题目的意图了：有一个8*8的矩阵迷宫，以’W’ ‘S’ ‘A’ ‘D’ 为移动方向，flag就是到达终点W的移动过程 flag{DSSDSSSDDWWDDDS}"},{"title":"WusT","date":"1999-11-23T12:46:42.000Z","url":"/1999/11/23/WusT/","categories":[[" ",""]],"content":"王阳明，明代著名的思想家、哲学家、教育家、军事家、文学家与书法家。他“以绝世之资倡其新说”，历经坎坷，参悟圣人之道，开创心学，以赫赫文功武治，成一代圣贤。那么，阳明的心学究竟是怎么样的学问呢？ 何为人生第一等事？ 王阳明十一岁时，有一天上课突然问先生，“何为第一等事？”人生的第一等事也就是最重要的事是什么？先生回答：“惟读书登第耳。”人生最重要的事，就是好好读书，然后考中科举、做官。王阳明不同意，说“登第恐未为第一等事，或读书学圣贤耳！”人生的第一等事是读书，学圣贤。他父亲听说后，就质问他：听说你想当圣人啊？你知道什么是圣人吗？别看王阳明才十一岁，却人小志气大，当即头一仰，大声说，圣人就是“为天地立心，为生民立命，为往圣继绝学，为万世开太平”的人。 为着“学圣贤”的人生理想，小小年纪的王阳明开始研习兵法、舞枪弄棒。十五岁的时候，为了继承前贤的遗志，王阳明径出居庸关、山海关，对边塞的地势地貌、山川形胜进行了一番实地考察。他还曾在蒙古族部落里参加了射箭和骑马比赛，居然拔得头筹。他十分向往东汉大将军马援的功业，云游归来，有感于动乱频仍的社会现实，写了《帝国平安策》欲上呈朝廷，被父亲训斥教育了一番。但由此可见，王阳明家国天下的胸怀和襟抱。 心外无物，心即理 心学中最重要的一个奠基理论：“心即理”，心外无物。心即理，意思是万事万物只有人类意识参与时才能明白，遇到事情“不动心”，不论发生什么事，都保持一颗岿然不动的心。 平宁王之乱的时候，王阳明并未到第一线去。他坐镇指挥的同时还在上课、讲心学。当他的手下大将伍文定正和宁王朱宸濠大战的时候，王阳明大概就在讲“不动如山”之境。这时候突然前方战报来了，说情况紧急，前敌总指挥伍文定的胡子都被烧着了，前方军心已乱。这时候，王阳明站起身来，走到旁边拿令牌传命下去：谁再说伍文定胡子被烧这件事，立刻给我斩了。然后调回头来继续上课。 学生们都很紧张，问外边怎么样了？王阳明摇摇头说，刚刚听人说前方有点不顺利，此兵家常事，不足介怀。我们继续讲。讲了一阵，又有前方战报来报，说宁王朱宸濠已经被活捉了，大乱平定。别人听到这样的消息，肯定要欢呼、庆祝。但是，王阳明听了，只是点点头，然后依旧接着回来上课。 学生们又忍不住问了：前方怎么样？王阳明说，听说宁王朱宸濠大败，而且已经被我们抓获了，想来这个消息不假。这时，王阳明眉头一皱说，就是听说死伤惨重啊！这里看出他的悲悯之心。但说完之后，又接着讲课，而且表现为“理前语如故”“理前语如常”，旁观者无不佩服。 这就是遇到事情“不动心”，不动如山，心外无物。 心外无物，其实是一种更大境界的价值存在。获得这种价值存在之后，人生就有了一个价值支撑，就有了一个价值出发点。人类的终极问题是不朽，怎么追求不朽？每个人的生命就像一滴水一样，就算再饱满，放在阳光下没多久就被蒸发掉了。这滴水怎么才能不被蒸发掉呢？很简单，放入旁边的长江大河，汇入汪洋大海之中。王阳明心学不是一种简单的自我解脱和现实逃避，而是一种社会担当、一种博大的胸怀，是树立正确的价值取向，然后勇于担当，勇于负责。 知行合一，事上练 阳明心学诞生后，王阳明兴办龙冈书院，授徒讲学，声名远播，后又受到贵州提学副使席书的邀请，讲学于贵阳书院。此后，王阳明的“心即理”不断延展，渐渐产生了“知行合一”的思想，这是他心学的第二大层次。“心即理”，可以说是心学的基石，“知行合一”则是心学重要的发展。 “知行合一”有一个十分重要的口诀，叫做“事上练”。碰到事，不怕事，这颗心要到事上去磨练，就像一把兵刃，要在磨刀石上磨练才能锋利一样。 王阳明在贵阳讲学，三年贬谪期满后，被朝廷任命为江西吉安府庐陵县知县。上任后第一天，“蓦有乡民千数拥入县门，号呼动地，一时不辨所言，大意欲求宽贷”。他很快明白了事情的来龙去脉，乡民们鸣冤，是因为庐陵这个地方不生产葛布，却要缴纳繁重的葛布税。 弄清了事情原委之后，王阳明先安抚乡民的情绪，开口表态：既然朝廷派我来庐陵县做父母官，如果确有不平、不是之处，我一定为大家做主。这样一表态，大家立刻安静了。然后，王阳明立刻召集县府有关人员开会，了解到这葛布税并非国家应收的税种，而是宦官搜刮民财的一种恶劣手段。之后，他向乡民们宣布，免去今年的葛布税。 这可不得了！王阳明刚刚新官上任，还没有跟上下级沟通，也没有跟官僚体系整体协调好关系，他就敢现场说今年就免去葛布税！手下人都吓坏了：这得要担多大的责任与风险？ 免去了乡民的葛布税之后，王阳明给上级政府写了封信，言之凿凿，陈明利弊，既不卑不亢晓之以理，又不动声色摆出态度，最后以人情动之，面对奸宦，软硬兼施，竟然就这么轻松圆满地把事情解决掉了。 “知行合一”，事上练。首先是具备调查、洞悉全局的能力，然后就是敢于担当，碰到事不怕事，而且敢于迎难而上。神奇的是，他越是迎难而上，越是敢于担当，后来他遇到的困难越是迎刃而解。这就是阳明心学的力量，强大的“知行合一”的智慧。 修身正心，致良知 王阳明，一介书生，身体羸弱，却勇斗宦官，剿南赣匪患，平宁王之乱，平广西匪患，战无不胜、攻无不克，成功的背后是心学“知行合一”的智慧。“知行合一”背后有个关键的地方，也是阳明心学的核心，堪称总纲中的总纲、精华中的精华，那就是——“致良知”。王阳明说：“此良知二字，实千古圣圣相传一点滴骨血也。” 阳明心学所说的这个良知，典出《孟子》“不学而能为之良能，不虑而知为之良知”。知天理、知人间大道，是一个人内心本来就有的，“人人皆有良知”，但因现实中各种欲望、情绪、不良习性蒙蔽了良知。因此要找到这个良知，找到人类文明积淀下来的智慧、道德与灵性的自觉，听从内心光明的指引，然后不停地去磨练它，升华它，激发一个人巨大的能力，使其不断成长。 宁王之乱时，王阳明本是奉圣旨去福建平士兵哗变，但听到朱宸濠的叛乱消息，立刻前往平叛，毫不犹豫！想想当时的环境，当年朱棣靖难之役的历史摆在那儿，再加上朱厚照本身昏庸、荒诞，宁王朱宸濠准备了十年，完全是有可能成功的。当时南方官员给朝廷的上疏都没说宁王反叛，而是说南昌有变、江西有变、江南有变，都在明哲保身，为自己留退路。只有王阳明知难而上。他也担心自己，甚至让家眷在自己家门外环布柴草，说一旦事败，绝不肯被俘，全家举火自焚，说明当时形势何其严迫。但是王阳明为什么可以挺身而出？就是这种“致良知”，听从内心光明的指引。知道什么事该做，什么事不该做。行为准则、行动智慧全都自然而然地出现了，这就是致良知的表现。 王阳明曾有四句教：“无善无恶心之体，有善有恶意之动，知善知恶是良知，为善去恶是格物。”这是阳明心学关键的总结和升华。宁王之乱平定后，忠泰之难接踵而来。张忠、许泰、江彬等人，处处刁难王阳明，甚至要陷害他。在那个危难时刻，王阳明的祖母去世了，父亲王华又病重，王阳明想回家，学生们都劝他不能走，疑谤在身，被朝廷猜忌，怀疑谋反，这个时候走了，别人就觉得是畏罪潜逃。但王阳明细想了一下，说：我的良知告诉我，亲情足以让我放下这一切。我的良知告诉我，我和亲人之间的感情是最基本的人性，是我要追求的最光辉的东西。如果这个东西都没有了，其他东西还有什么必要呢？王阳明就真的辞职不干了。这说明，他自己内心中的良知是他处事的最高指引，而不是外在世俗的标准。这就是，听从内心的指引——“致良知”。 王阳明堪称中国历史上真正能够做到立德、立功、立言三不朽的典范，我在《五百年来王阳明》书中也讲述了他在常人难以想象的百死千难中积累人生的经验和智慧。他对真理不懈追求的精神，他讲学问道付诸实行、在艰难中建功立业的功夫，他经过修炼而获得强大内心以及战胜苦难的决心和勇气，值得我们去学习、去体悟。 作者：南京师范大学教授，《百家讲坛》主讲人，著有《五百年来王阳明》等 第二处宝藏: ing@_4 第三处线索 ./get_final_treasure.php"},{"title":"About me","date":"2020-12-24T04:12:58.000Z","url":"/about/index.html","categories":[[" ",""]],"content":" 还差得远，虚心学习..&nbsp; "},{"title":"friends","date":"2021-07-19T15:13:16.861Z","url":"/friends/index.html","categories":[[" ",""]]},{"date":"2021-01-15T16:10:27.230Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2021-01-13T08:20:40.000Z","url":"/tags/index.html","categories":[[" ",""]]}]